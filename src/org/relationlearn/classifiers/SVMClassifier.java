package org.relationlearn.classifiers;

import java.io.File;
import org.relationlearn.exception.ClassifierNotTrainedException;
import weka.classifiers.Evaluation;
import weka.classifiers.functions.LibSVM;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SerializationHelper;

/**
 * Class used to encapsulate all operations that may be performed with an 
 * SVM classifier including storage of trained classifiers and classification 
 * of Instance objects generated by code.
 * 
 * @see org.relationlearn.util.InstanceGenerator
 * @see weka.classifiers.functions.LibSVM
 */
public class SVMClassifier {
    
    private final LibSVM SVM;
    private Instances TRAIN_INS;
    
    /**
     * Constructs a new untrained SVM classifier.
     */
    public SVMClassifier() {
        SVM = new LibSVM();
    }
    
    /**
     * Constructs a new trained SVM classifier using the data stored in the
     * {@code model} parameter.
     * 
     * @param model the File containing the trained classifier and its dataset
     * @throws Exception if any error regarding file reading or object
     * deserialization happens
     */
    public SVMClassifier(File model) throws Exception {
        Object objs[] = SerializationHelper.readAll(model.getAbsolutePath());
        SVM = tryCastObject(objs[0], LibSVM.class);
        TRAIN_INS = tryCastObject(objs[1], Instances.class);
    }
    
    /**
     * Sets specific SVM classifier options. 
     * <p/>
     * For more info on options paramters
     * please refer to the {@link weka.classifiers.functions.LibSVM} javadoc
     * page.
     * 
     * @param options option array to be passed to the SVM classifier
     * @throws Exception if option parsing fails
     */
    public void setOptions(String options[]) throws Exception {
        this.SVM.setOptions(options);
    }
    
    /**
     * Trains this SVM classifier with the data found in {@code trainData}.
     * 
     * @param trainData the data to be used for this classifier training
     * @throws Exception if any problem related to the SVM classifier happens
     */
    public void trainClassifier(Instances trainData) throws Exception {
        SVM.buildClassifier(trainData);
        TRAIN_INS = trainData;
    }
    
    /**
     * Tries to store both the classifier and the training dataset in the path
     * {@code path} in serialized form.
     * 
     * @param path the path where the data will be stored
     * @throws Exception if any error related to the serialization process
     * happens
     */
    public void storeModel(String path) throws Exception {
        Object objs[] = new Object[2];
        objs[0] = SVM;
        objs[1] = TRAIN_INS;
        SerializationHelper.writeAll(path, objs);
    }
    
    /**
     * Classifies the Instance {@code instance} and returns its prediction
     * value.
     * 
     * @param instance the Instance to be classified
     * @return the prediction value for this Instance
     * @throws Exception if any error related to the classification happens
     * or if the classifier is not trained
     * 
     * @see Instance
     */
    public double classifyInstance(Instance instance) throws Exception {
        if(TRAIN_INS != null) {
            return SVM.classifyInstance(instance);
        } else {
            throw new ClassifierNotTrainedException();
        }
    }
    
    /**
     * Evaluates this classifier using a the test Instances provided by
     * the parameter {@code test}.
     * 
     * @param test the Instances to be used in evaluating the classifier
     * @return the array of prediction values
     * @throws Exception if any error related to the evaluation happens
     * or if the classifier is not trained 
     */
    public double[] testClassifier(Instances test) throws Exception {
        if(TRAIN_INS != null) {
            Evaluation eval = new Evaluation(TRAIN_INS);
            return eval.evaluateModel(SVM, test);
        } else {
            throw new ClassifierNotTrainedException();
        }
    }
    
    private <T> T tryCastObject(Object objs, Class<T> type) 
            throws IllegalArgumentException {
        if(!type.isInstance(objs)) {
            throw new IllegalArgumentException("File is not a correct model");
        } else {
            return type.cast(objs);
        }
        
    }

}
